import{_ as s,o as a,c as o,Q as p}from"./chunks/framework.b8c8dad6.js";const h=JSON.parse('{"title":"Router 路由","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/docs/router.md","filePath":"markdown/docs/router.md"}'),n={name:"markdown/docs/router.md"},l=p(`<h1 id="router-路由" tabindex="-1">Router 路由 <a class="header-anchor" href="#router-路由" aria-label="Permalink to &quot;Router 路由&quot;">​</a></h1><p>路由，用于根据路径决定所具体执行的 Api。</p><p>在 <a href="/bao-docs/markdown/docs/install.html">Install</a> 章节中，你可能已经体验到了路由的&quot;魔法&quot;。在 Bao 中，路由几乎是不用你来亲自编写的。Bao 会自动寻找在 <code>/src/app</code> 目录下名为 <code>api.ts</code> 的文件，并为你自动生成路由。它的生成规则，就像下面这样：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">toHyphen</span><span style="color:#E1E4E8;">(你的路径 </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;/&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> 方法名);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">toHyphen</span><span style="color:#24292E;">(你的路径 </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;/&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> 方法名);</span></span></code></pre></div><p>假设，你编写了一个 <a href="/bao-docs/markdown/docs/api.html">Api</a> 文件，其中，有一个 <code>helloWorld</code> 的方法，路径为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">/src/app/foo/bar/api.ts</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">/src/app/foo/bar/api.ts</span></span></code></pre></div><p>此时，只要访问 <code>http://localhost:9000/foo/bar/hello-world</code> 即可执行这个 Api。</p><h2 id="补充路由逻辑" tabindex="-1">补充路由逻辑 <a class="header-anchor" href="#补充路由逻辑" aria-label="Permalink to &quot;补充路由逻辑&quot;">​</a></h2><p>几乎所有的情况，你都应该使用 Bao 为你自动生成的路由。只有在特殊情况下，你才必须要自定义你的路由。此时，你可以编辑你的 <code>/src/router.ts</code> 文件。它的内容看起来像这样：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> ApiParams </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;../generate/products/api-params&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">routerHandler</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">path</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">fullurl</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">URL</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">keyof</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> ApiParams)[</span><span style="color:#9ECBFF;">&quot;params&quot;</span><span style="color:#E1E4E8;">]&gt; </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">type</span><span style="color:#24292E;"> ApiParams </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;../generate/products/api-params&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">routerHandler</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">async</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">path</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">, </span><span style="color:#E36209;">fullurl</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">URL</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Promise</span><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">false</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">keyof</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> ApiParams)[</span><span style="color:#032F62;">&quot;params&quot;</span><span style="color:#24292E;">]&gt; </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>你可以编辑这个方法的内容，来补充除了 Bao 自动为你生成的路由之外的，你期望的路由匹配逻辑。你可以 <code>return</code> 一个已存在的 Api 地址，它将被调用。如果你 <code>return false</code>，则会返回 <code>not-found</code> 的失败信息。</p><p>同时，它接受两个参数，<code>path</code> 和 <code>fullurl</code>。<code>path</code> 代表请求的路径后缀（删除了前面的域名和 <a href="/bao-docs/markdown/docs/config-framework.html#ignorepathlevel">忽略的路径层级</a>），出于性能考虑，如果访问的 URL 中携带了 Parameters，则不会被删除，依旧保留在 <code>path</code> 中，像 <code>foo/bar?hello=world</code> 这样。<code>fullurl</code> 则是完整的 URL 对象，<a href="/bao-docs/markdown/docs/config-framework.html#ignorepathlevel">忽略的路径层级</a> 不会被删除。</p><p>注意，这个方法的优先级永远比 Bao 为你自动生成的路由的优先级低，这意味着你不能做到禁止某个 Api 被访问。这么设计是为了保证你尽量只在这里编写路由匹配的规则，如果你需要完成某种授权才能访问某个 Api，请使用 <a href="/bao-docs/markdown/docs/middleware.html">中间件</a> 功能。如果你需要禁止一个 Api 本身被直接调用，而通过此处编写的匹配规则可以间接访问，请在 Api 本身的代码中编写判断逻辑，并在合适的地方使其失败并返回 <code>not-found</code>。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">defineFail</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;not-found&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">defineFail</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;not-found&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;">);</span></span></code></pre></div>`,14),e=[l];function t(c,r,y,E,d,i){return a(),o("div",null,e)}const F=s(n,[["render",t]]);export{h as __pageData,F as default};
