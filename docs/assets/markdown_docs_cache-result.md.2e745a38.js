import{_ as s,o as a,c as o,Q as n}from"./chunks/framework.b8c8dad6.js";const u=JSON.parse('{"title":"CacheResult","description":"","frontmatter":{"title":"CacheResult"},"headers":[],"relativePath":"markdown/docs/cache-result.md","filePath":"markdown/docs/cache-result.md"}'),l={name:"markdown/docs/cache-result.md"},e=n(`<h1 id="结果缓存" tabindex="-1">结果缓存 <a class="header-anchor" href="#结果缓存" aria-label="Permalink to &quot;结果缓存&quot;">​</a></h1><p>将一个方法的结果缓存一段时间。下次调用时，将优先从缓存中获取。</p><p>当应用遇到较高的并发时，结果缓存功能可以有效帮助我们缓解数据库的压力，或者避免重复执行一些耗时的运算，提高你的应用的整体吞吐量。</p><h2 id="配置" tabindex="-1">配置 <a class="header-anchor" href="#配置" aria-label="Permalink to &quot;配置&quot;">​</a></h2><p>请确保你已经配置好了 Redis，可以参见上一个缓存章节来了解。</p><h2 id="逻辑" tabindex="-1">逻辑 <a class="header-anchor" href="#逻辑" aria-label="Permalink to &quot;逻辑&quot;">​</a></h2><p>使用 <code>defineResultCache</code> 方法来定义一个结果缓存，你需要传递的参数中，会包含一个方法。你需要在此方法中编写你需要缓存的运算。</p><p>当代码执行到 <code>defineResultCache</code> 时，当缓存未过期时，会从缓存中读取结果。如果过期，则会运行你的方法获取结果，同时，将结果重新缓存起来。</p><p>为了缓解遭遇缓存雪崩的概率，你需要设置两个过期的秒数，分别是 <code>TTL</code> 和 <code>realTTL</code>。</p><p>当 <code>TTL</code> 未过期时，处于正常缓存阶段，此时，所有的结果都来自于缓存。</p><p>当 <code>TTL</code> 过期后，此时处于缓存过期阶段，此时，Bao 会允许 1 个请求去重新运算你的结果，并进入重新计算阶段。</p><p>在重新运算阶段期间，其他请求会获取到的是原先的旧数据缓存，直到重新运算阶段结束，回归正常缓存阶段，并更新了缓存。</p><p>重新运算阶段可能会失败，导致回归缓存过期阶段。此时，下一个请求到达时，会重新进入重新运算阶段。重新运算阶段在默认情况下持续 6 秒，如果超过了 6 秒未成功，则认为重新运算失败。可通过 <code>options.realGetInterval</code> 来修改这个超时时间。</p><p>当 <code>TTL + realTTL</code> 也同样过期后，缓存的结果，将会从缓存中彻底删除。</p><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">result</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">defineResultCache</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;your-key&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">60</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">60</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">now</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Date</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(resolve, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">)); </span><span style="color:#6A737D;">// sleep for 1 second</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> now;</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">result</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">defineResultCache</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;your-key&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">60</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">60</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">async</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">now</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Date</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getTime</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(resolve, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">)); </span><span style="color:#6A737D;">// sleep for 1 second</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> now;</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><h2 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h2><ul><li><p><code>key: string</code>: 缓存的键</p></li><li><p><code>TTL: number</code>: 缓存过期的秒数</p></li><li><p><code>realTTL: number</code>: 缓存过期后，距离真实删除缓存的秒数</p></li><li><p><code>fn: Function</code>: 要缓存的方法</p></li><li><p><code>options: { realGetInterval?: number; }</code>: 选项</p></li></ul>`,18),p=[e];function t(c,r,E,y,i,d){return a(),o("div",null,p)}const F=s(l,[["render",t]]);export{u as __pageData,F as default};
