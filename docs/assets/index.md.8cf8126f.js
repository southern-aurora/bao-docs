import{_ as a,o,c as e,Q as p}from"./chunks/framework.f6f75689.js";const y=JSON.parse('{"title":"Bao","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"index.md","filePath":"index.md"}'),t={name:"index.md"},s=p('<h1 id="bao" tabindex="-1">Bao <a class="header-anchor" href="#bao" aria-label="Permalink to &quot;Bao&quot;">​</a></h1><p>高性能的 Bun 框架，以人为本，你代码中的人体工学椅。</p><blockquote><p>Bao 的 1.0 版本尚未发布，有 Api 变更的可能性。不推荐在生产环境中使用。</p></blockquote><h2 id="bao-是如何诞生的" tabindex="-1">Bao 是如何诞生的？ <a class="header-anchor" href="#bao-是如何诞生的" aria-label="Permalink to &quot;Bao 是如何诞生的？&quot;">​</a></h2><p>在创造 Bao (中国语中&quot;包子&quot;的意思) 之前，我曾经尝试过很多框架，只是，我没有找到一个框架，它能够让我在开发的时候，感觉到足够的舒适。</p><p>最终，我决定自己创造一个框架，她通过许多巧妙的设计，让你在编码过程中降低心智负担、解放大脑，同时兼顾性能。</p><p>此时，恰好 Bun 的 <code>1.0</code> 版本发布，我决定使用她来编写这个新框架，就是 Bao。</p><h2 id="设计哲学" tabindex="-1">设计哲学 <a class="header-anchor" href="#设计哲学" aria-label="Permalink to &quot;设计哲学&quot;">​</a></h2><p>我崇尚 Go 语言之父 Rob Pike 的&quot;大道至简&quot;。</p><p>学习曲线，是我在设计 Bao 之初最关注的地方。我希望 Bao 能够尽可能的简单，即便是没有后端经验的前端开发者，也可以在 1 天之内学会 Bao 并开始编写你的后端代码。</p><p>因此，我尽量不采用 <code>DI</code>，以及 <code>Decorator</code> 或 <code>Annotation</code> 等糖，而是让开发者使用最简单最直观的方式来编写后端代码。</p><p>我也希望尽可能地简化概念，Bao 摒弃了诸如 <code>DDD</code>、<code>Router</code>、<code>Controller</code>、<code>Service</code>、<code>Entity</code>、<code>DAO</code> 等复杂的概念，而是以一种巧妙的方式，简化开发者的学习曲线。</p><p>Bao 也并非是那种，虽然轻量，一旦多人协作，代码就会变得一团乱麻的框架。Bao 有着良好的工程化支持，多人协作的场景在 Bao 设计时也是关注的重点。</p><h2 id="为什么要使用-bao" tabindex="-1">为什么要使用 Bao？ <a class="header-anchor" href="#为什么要使用-bao" aria-label="Permalink to &quot;为什么要使用 Bao？&quot;">​</a></h2><p>Bao 旨在保证高性能的同时，解决在传统后端开发过程中的痛点，让你在编码过程中，感受到足够的舒适。解放你的大脑，降低心智负担，使你可以专注于你的业务。下面，我们来看举例一些实际的场景，如果你觉得这些点让你感受到了痛苦，不妨来试试 Bao。</p><h3 id="对接-api" tabindex="-1">对接 API <a class="header-anchor" href="#对接-api" aria-label="Permalink to &quot;对接 API&quot;">​</a></h3><p>传统的后端工程中，最让人痛苦的地方，我觉得，莫过于是对接 API 阶段。</p><p>假设，我们要编写一个简单的新增数据接口，来看看会遇到哪些麻烦：</p><h4 id="第一个麻烦-序列化" tabindex="-1">第一个麻烦：序列化 <a class="header-anchor" href="#第一个麻烦-序列化" aria-label="Permalink to &quot;第一个麻烦：序列化&quot;">​</a></h4><p>在前端，我们先将收集到的用户填入的新增数据，序列化为 <code>JSON</code> 并发送给后端的新增接口中。</p><p>此时我们遇到了第一个麻烦：<code>JSON</code> 所支持的类型有限。</p><p>如果用户填入的数据包含 <code>Date</code>，那么我们需要手动将时间转换为字符串或时间戳，然后再在后端手动还原它们。</p><p>或许你还会用到 <code>bigint</code>、<code>Set</code>、<code>Map</code>、<code>URL</code>，而这些类型都需要你手动转换。</p><p>在 Bao 中，你不需要手动处理任何类型，甚至不需要编写 <code>JSON.stringify</code>，Bao 会自动帮你处理。</p><h4 id="第二个麻烦-参数校验与类型安全" tabindex="-1">第二个麻烦：参数校验与类型安全 <a class="header-anchor" href="#第二个麻烦-参数校验与类型安全" aria-label="Permalink to &quot;第二个麻烦：参数校验与类型安全&quot;">​</a></h4><p>当我们花精力处理了这些问题之后，我们遇到了第二个麻烦：我们不知道用户填入的数据是否符合我们的预期。</p><p>用户的输入都是不可信的，有些参数是可选的、有些是必选的，有些数字的取值范围是有限的，有些字符串又有最大长度的限制。</p><p>我们需要继续花费精力，来校验用户的输入，以确保最终处理的数据是可靠的。</p><p>在 Bao 中，所有的参数都是类型安全的。同时，你还可以通过泛型来限制参数是否可选，甚至是限制数字的取值范围、一个字符串是否是邮箱。</p><h4 id="第三个麻烦-typescript-类型" tabindex="-1">第三个麻烦：TypeScript 类型 <a class="header-anchor" href="#第三个麻烦-typescript-类型" aria-label="Permalink to &quot;第三个麻烦：TypeScript 类型&quot;">​</a></h4><p>当我们处理完这一切后，我们发现了第三个麻烦：</p><p>后端给我们的大概只是一份 API 文档，作为前端开发者，需要将这份文档手工转换为 TypeScript 类型。即便这些后端可能是由 TypeScript 编写的。</p><p>而如果未来后端接口发生了变更，我们还需要手动同步修改 TypeScript 类型。后端人工通知前端开发者，然后再由不情愿的前端开发者去手动修改。</p><p>在 Bao 中，你可以为前端构建出一个 npm 包，让前端开发者直接使用你的包，来与你通信，就像：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">result</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> client.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;hello/world&quot;</span><span style="color:#E1E4E8;">, { name: </span><span style="color:#9ECBFF;">&quot;alice&quot;</span><span style="color:#E1E4E8;"> });</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">result</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> client.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello/world&quot;</span><span style="color:#24292E;">, { name: </span><span style="color:#032F62;">&quot;alice&quot;</span><span style="color:#24292E;"> });</span></span></code></pre></div><p>包是可以自由定制的，你甚至可以将你的业务逻辑写在包中，譬如，当 Token 失效后自动刷新 Token。</p><h4 id="第四个麻烦-自动化测试" tabindex="-1">第四个麻烦：自动化测试 <a class="header-anchor" href="#第四个麻烦-自动化测试" aria-label="Permalink to &quot;第四个麻烦：自动化测试&quot;">​</a></h4><p>完成这一切后，运行我们的代码，哈！报错了！</p><p>是的，通常后端没有自动化测试，我们需要手动调试接口，来验证我们的代码是否正确。</p><p>而没有自动化测试的原因除了开发者不愿意编写测试之外，还有就是，除非在框架设计之初就重视测试，否则，这些操作很难被自动化。</p><p>因为，你需要执行启动 Web Server、连接数据库、初始化数据、执行测试、清理数据、关闭 Web Server 这一系列操作。</p><p>Bao 在设计之初就考虑到了自动化测试，尽管不是必须的，但是，你可以很方便的为每个接口都编写一个测试文件。</p><p>同时，我们建议不使用诸如 Postman 等工具来调试你的 API 接口，而是通过运行你编写的测试文件来调试。</p><h3 id="http-的复杂性与路由" tabindex="-1">HTTP 的复杂性与路由 <a class="header-anchor" href="#http-的复杂性与路由" aria-label="Permalink to &quot;HTTP 的复杂性与路由&quot;">​</a></h3><p>HTTP 功能很强大，同时又很复杂。</p><p>例如，我们要考虑一个接口要采用 <code>GET</code> 还是 <code>POST</code>，抑或是 <code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>。</p><p>如果接口是 <code>GET</code>，那么我们的参数不能直接序列化为 <code>JSON</code> 放在请求体中，而是需要转换成 URL Parameters，即 <code>foo?bar=baz&amp;qux=fred</code> 的形式拼接在 URL 中，这会比 <code>JSON</code> 更糟：URL Parameters 无法区分数字与字符串以及其他类型，更不支持数组、对象深层嵌套，还有最大长度限制。</p><p>鉴于 HTTP 的复杂性，传统许多框架都会提供路由的功能，通过编写路由来决定，一串用户输入的 URL 如何映射到某个实际的控制器。</p><p>但 HTTP 的许多设计来源于上一个时代：那个时代还没有前端与后端的分工，HTML 页面是由后端拼接而成的。所以像动态路由、路由参数、重定向等功能，对于如今已经前后端分离、只需要提供 API 供前端调用的我们来说，是没有必要的。</p><p>而且，路由的存在有时也会令我们痛苦：我经常写好了接口但因为忘记添加路由，而导致刷新了半天都找不到页面，最后才回忆起添加路由。</p><p>Bao 遵循约定大于配置，很好的隐藏了 HTTP 的复杂性。你可以在 <code>/src/app</code> 中自由组织目录，其中所有的名为 <code>api.ts</code> 的文件，其中的每个函数都会被自动映射为一个接口。当然，这并非意味着你失去了对 HTTP 的控制，你依然可以自由定义接口的 HTTP 方法、状态码、返回值。</p><h3 id="更多内容" tabindex="-1">更多内容？ <a class="header-anchor" href="#更多内容" aria-label="Permalink to &quot;更多内容？&quot;">​</a></h3><p>我相信你已经感受到了 Bao 的与众不同，除了上面的泛泛而谈，Bao 还在许多其他细节之处。继续阅读文档，你会发现更多的惊喜。</p>',53),c=[s];function n(l,r,d,i,h,u){return o(),e("div",null,c)}const E=a(t,[["render",n]]);export{y as __pageData,E as default};
