import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.064d4bf4.js";const h=JSON.parse('{"title":"Use","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/docs/use.md","filePath":"markdown/docs/use.md"}'),l={name:"markdown/docs/use.md"},p=e(`<h1 id="use" tabindex="-1">Use <a class="header-anchor" href="#use" aria-label="Permalink to &quot;Use&quot;">​</a></h1><p>Use 位于 <code>/src/use</code> 目录，它是一个没有任何&quot;魔法&quot;的目录。我们约定俗成，将一些通用的功能放在这里，并以 <code>use</code> 开头。</p><h2 id="编写" tabindex="-1">编写 <a class="header-anchor" href="#编写" aria-label="Permalink to &quot;编写&quot;">​</a></h2><p>我们约定俗成，一个 <code>use</code> 文件，以下面的方式来编写：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UseSayHelloOptions</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">useSayHello</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">options</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UseSayHelloOptions</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;hello world&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UseSayHelloOptions</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">useSayHello</span><span style="color:#24292E;">(</span><span style="color:#E36209;">options</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UseSayHelloOptions</span><span style="color:#24292E;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">sayHello</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello world&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>它导出且只导出一个方法，方法名以 <code>use</code> 开头，方法名的后缀是你的功能名。</p><p>方法的参数是一个对象，对象中包含了你的功能的配置项。</p><p>方法的返回值是一个对象，对象中包含了各种执行你的功能的方法。</p><h2 id="use-是-service-吗" tabindex="-1">Use 是 Service 吗？ <a class="header-anchor" href="#use-是-service-吗" aria-label="Permalink to &quot;Use 是 Service 吗？&quot;">​</a></h2><p>如果你有接触了其他的后端框架的经验，Service 的概念应该不陌生。有些人可能会认为 Use 就是 Bao 中的 Service，但是，我们认为 Use 和 Service 是截然不同的：</p><ul><li><p>Service 通常由 DI 容器来管理，是一个单例。而 Bao 没有 DI 容器，Use 是一个方法，根据参数来构造你所需要的对象。</p></li><li><p>Use 比 Service 更纯粹，它不应该以业务命名（比如 <code>useUser</code>，提供增删改查用户的功能），而是应该以功能命名（比如 <code>useDatabase</code>，提供与数据库的通信和封装功能）。</p></li><li><p>业务逻辑应该写在 Api Action 中，而不是写在 Use 中。</p></li><li><p>我们约定俗成，Use 之间不进行互相调用。</p></li></ul><h2 id="为什么要这样做-controller-service-不好吗" tabindex="-1">为什么要这样做？Controller-Service 不好吗？ <a class="header-anchor" href="#为什么要这样做-controller-service-不好吗" aria-label="Permalink to &quot;为什么要这样做？Controller-Service 不好吗？&quot;">​</a></h2><p>许多后端的开发者习惯将一切逻辑都放在 Service 中，Controller 几乎只是一个校验检查传入的数据、并调用 Service 的地方。他们严格遵循只在 Service 中才会编写查询数据库的代码。</p><p>在 Bao 中，我们不推荐这样做。我们认为，应该将所有的逻辑都写在 Api 的 Action 中。这可能会导致部分代码的冗余，例如，在获取文章详细信息的功能中，也有必要获取用户信息。这会导致我们在编写文章详细信息 Api 时，额外多编写一遍获取用户信息的代码。</p><p>但是，这样的冗余我认为是有必要的。这会为我们多人协作时带来更多的好处：代码简洁而直观，尤其是对于新加入的协作者而言，他们没有时间也不愿意去熟悉项目的旧逻辑，他们只想快速的开始编写新的业务。如果限制他们只能在 Service 中编写逻辑，那么他们就必须去了解旧的逻辑，而 Service 与 URL 并非是严格一一对应的，这会导致他们花费大量的时间和精力在熟悉旧的业务逻辑当中。这也是我认为 DDD 的弊端所在。</p><p>同时，如果一旦需求变动，比如获取文章详细信息中，不要获取用户的邮箱与手机号，而在修改用户资料的获取用户信息中，需要额外的获取用户的邮箱与手机号，在前期系统设计时没有考虑到这些需求，就会导致后期的代码变得越来越混乱。</p><p>因此，在 Bao 中，我们约定俗成，Use 将会是一个比 Service 更纯粹的东西，它只是一些通用的功能的封装，而不应该包含任何业务逻辑。</p><p>Use 之间不应该相互调用，如果一个需求你认为需要多个 Use 才能完成，那么你应该在 Api Action 中，通过调用多个 Use 的方式完成，而不是在 Use 中相互调用。</p>`,18),o=[p];function c(t,r,i,E,y,d){return a(),n("div",null,o)}const v=s(l,[["render",c]]);export{h as __pageData,v as default};
